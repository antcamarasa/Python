ğŸ§  Comprendre la rÃ©cursion et la gestion de la profondeur (level) dans un dictionnaire imbriquÃ©
ğŸ¯ Objectif

Afficher chaque clÃ© et son niveau dâ€™imbrication dans un dictionnaire potentiellement imbriquÃ©.

âš™ï¸ 1. Version de base â€” passage du niveau par valeur

  def search_key_in_dict_nested(d: dict):

    def helper_recursive(d, level):
        for k, v in d.items():
            current_level = level
            if not isinstance(v, Mapping):
                print(f"Level : {current_level} key : {k}")
            else:
                print(f"Level : {current_level} key : {k}")
                helper_recursive(v, current_level + 1)

    helper_recursive(d, 0)


ğŸ” ComprÃ©hension

helper_recursive(v, current_level + 1) passe une nouvelle valeur du niveau Ã  chaque appel.

Chaque appel rÃ©cursif crÃ©e une nouvelle frame (contexte dâ€™exÃ©cution).

Le level du parent nâ€™est jamais modifiÃ© :
il reste identique quand on revient de la rÃ©cursion.

ğŸ‘‰ Ici, level + 1 est une simple expression : elle calcule une valeur sans affecter la variable level dans la frame actuelle.

ğŸ§© SchÃ©ma de frames

  Frame A: level = 0
  â”œâ”€â”€ clÃ© children â†’ appel avec (level + 1 = 1)
       Frame B: level = 1
          â”œâ”€â”€ clÃ© pets â†’ appel avec (level + 1 = 2)
               Frame C: level = 2
          â† Retour â†’ level du parent (1) inchangÃ©

âœ… Propre, simple, sans dÃ©crÃ©mentation manuelle.

âš™ï¸ 2. Version avec incrÃ©mentation / dÃ©crÃ©mentation manuelle

  def search_key_in_dict_nested_second_iteration(d: dict):

    def helper_recursive(d, level):
        for k, v in d.items():
            if not isinstance(v, Mapping):
                print(f"Level : {level} key : {k}")
            else:
                level += 1
                print(f"Level : {level} key : {k}")
                helper_recursive(v, level)
                level -= 1

    helper_recursive(d, 0)

ğŸ” ComprÃ©hension
level += 1 modifie la variable level dans la frame courante.

Il faut donc la dÃ©crÃ©menter (level -= 1) aprÃ¨s le retour de la rÃ©cursion pour revenir Ã  la profondeur dâ€™origine.

Câ€™est une gestion manuelle de la montÃ©e/descente, utile quand on veut contrÃ´ler la profondeur directement dans la mÃªme frame.

ğŸ§© SchÃ©ma de frames et du level

Frame A: level = 0
  â†‘ level += 1 â†’ 1
  â”œâ”€â”€ Appel rÃ©cursif (Frame B: level = 1)
  â†“ level -= 1 â†’ revient Ã  0

  âš ï¸ Si on oublie le level -= 1, le niveau reste â€œbloquÃ©â€ Ã  1, donc les affichages suivants seraient faux.
Cette version simule manuellement la descente et la remontÃ©e dans la pile.

âœ… Utile pour comprendre comment la pile redescend, mais plus fragile.


âš™ï¸ 3. Version pure et sÃ»re â€” passage dâ€™un level calculÃ©

    def search_key_in_dict_nested_third_iteration(d: dict):

    def helper_recursive(d, level):
        for k, v in d.items():
            if not isinstance(v, Mapping):
                print(f"Level : {level} key : {k}")
            else:
                print(f"Level : {level} key : {k}")
                helper_recursive(v, level + 1)

    helper_recursive(d, 0)


ğŸ” ComprÃ©hension

level + 1 crÃ©e une nouvelle valeur temporaire (par exemple 2), passÃ©e Ã  lâ€™appel suivant.

Le parent ne modifie rien dans sa propre frame.

Le fils reÃ§oit sa propre copie de level, indÃ©pendante de celle du parent.

Quand le fils termine, on revient au parent avec son level inchangÃ©.

ğŸ§© SchÃ©ma de frames :

Frame Parent: level = 1
   helper_recursive(v, level + 1) â†’ appel avec valeur 2
      Frame Enfant: level = 2
         ...
   â† retour â†’ Frame Parent toujours level = 1

âœ… Le plus propre :
pas de mutation,
pas de dÃ©crÃ©mentation Ã  gÃ©rer,
chaque niveau est isolÃ© et cohÃ©rent.
