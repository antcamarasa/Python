# Dictionnaire
- [Premiers pas avec les dictionnaires en Python](#premiers-pas-avec-les-dictionnaires-en-python)
- [Cr√©er des dictionnaires en Python](#cr√©er-des-dictionnaires-en-python)
  - [Litt√©raux de dictionnaire](#litt√©raux-de-dictionnaire)
  - [Le constructeur dict()](#le-constructeur-dict)
  - [Utiliser la m√©thode de classe .fromkeys()](#utiliser-la-m√©thode-de-classe-fromkeys)
- [Acc√©der aux valeurs d‚Äôun dictionnaire](#acc√©der-aux-valeurs-dun-dictionnaire)
- [Remplir un dictionnaire de mani√®re progressive](#remplir-un-dictionnaire-de-mani√®re-progressive)
  - [Attribuer des cl√©s manuellement](#attribuer-des-cl√©s-manuellement)
  - [Ajouter des cl√©s dans une boucle for](#ajouter-des-cl√©s-dans-une-boucle-for)
  - [Construire des dictionnaires avec des compr√©hensions](#construire-des-dictionnaires-avec-des-compr√©hensions)
- [Explorer les m√©thodes de la classe dict](#explorer-les-m√©thodes-de-la-classe-dict)
  - [R√©cup√©rer des donn√©es depuis un dictionnaire](#r√©cup√©rer-des-donn√©es-depuis-un-dictionnaire)
  - [Ajouter des paires cl√©-valeur et mettre √† jour un dictionnaire](#ajouter-des-paires-cl√©-valeur-et-mettre-√†-jour-un-dictionnaire)
  - [Supprimer des donn√©es d‚Äôun dictionnaire](#supprimer-des-donn√©es-dun-dictionnaire)
- [Utiliser les op√©rateurs avec les dictionnaires](#utiliser-les-op√©rateurs-avec-les-dictionnaires)
  - [Appartenance : in et not in](#appartenance-in-et-not-in)
  - [√âgalit√© et in√©galit√© : == et !=](#√©galit√©-et-in√©galit√©--et-)
  - [Union et union augment√©e : | et |=](#union-et-union-augment√©e--et-)
- [Utiliser les fonctions int√©gr√©es avec les dictionnaires](#utiliser-les-fonctions-int√©gr√©es-avec-les-dictionnaires)
  - [V√©rifier la pr√©sence de valeurs vraies : all() et any()](#v√©rifier-la-pr√©sence-de-valeurs-vraies-all-et-any)
  - [D√©terminer le nombre d‚Äô√©l√©ments d‚Äôun dictionnaire : len()](#d√©terminer-le-nombre-d√©l√©ments-dun-dictionnaire-len)
  - [Trouver les valeurs minimales et maximales : min() et max()](#trouver-les-valeurs-minimales-et-maximales-min-et-max)
  - [Trier un dictionnaire par cl√©s, valeurs ou √©l√©ments : sorted()](#trier-un-dictionnaire-par-cl√©s-valeurs-ou-√©l√©ments-sorted)
  - [Faire la somme des valeurs d‚Äôun dictionnaire : sum()](#faire-la-somme-des-valeurs-dun-dictionnaire-sum)
- [It√©rer sur les dictionnaires](#it√©rer-sur-les-dictionnaires)
  - [Parcourir un dictionnaire par ses cl√©s](#parcourir-un-dictionnaire-par-ses-cl√©s)
  - [It√©rer sur les valeurs d‚Äôun dictionnaire](#it√©rer-sur-les-valeurs-dun-dictionnaire)
  - [Boucler √† travers les √©l√©ments d‚Äôun dictionnaire](#boucler-√†-travers-les-√©l√©ments-dun-dictionnaire)
- [Explorer les classes existantes similaires aux dictionnaires](#explorer-les-classes-existantes-similaires-aux-dictionnaires)
- [Cr√©er ses propres classes similaires aux dictionnaires](#cr√©er-ses-propres-classes-similaires-aux-dictionnaires)
- [Conclusion](#conclusion)


## [Premiers pas avec les dictionnaires en Python](#premiers-pas-avec-les-dictionnaires-en-python)
Les dictionnaires sont l‚Äôun des types de donn√©es int√©gr√©s les plus importants et utiles de Python.
Ils offrent une collection mutable de paires cl√©-valeur, permettant d‚Äôacc√©der et de modifier efficacement les valeurs √† l‚Äôaide de leurs cl√©s correspondantes.

            config = {
              "color": "green",
              "width": 42,
              "height": 100,
              "font": "Courier",
            }

            # Access a value throught its key
            config["color"]
            >>> "green"

            #Update a value 
            config["font"] = "Helvetica"
            
            print(config)
            {
              'color': 'green',
              'width': 42,
              'height': 100,
              'font': 'Helvetica'
            }

Un dictionnaire python est une collection de paire "cl√©-valeurs", ou chaque cl√© correspond a une valeur. Dans l'exemple:
- 'color' est une cl√©s
et,
- 'green' et la valeur associ√© a cette cl√©.

Les dictionnaires sont une partie fondamentale de Python. On les retrouve derri√®re des concepts essentiels tels que les espaces de noms (namespaces) et les port√©es (scopes), comme on peut le constater avec les fonctions int√©gr√©es globals() et locals() :


        >>> globals()
        {
          '__name__': '__main__',
          '__doc__': None,
          '__package__': None,
          ...
        }

La fonction globals() renvoie un dictionnaire contenant des paires cl√©-valeur qui associent des noms aux objets pr√©sents dans votre port√©e globale actuelle.

Python utilise √©galement des dictionnaires pour g√©rer l‚Äôimpl√©mentation interne des classes. Consid√©rez l‚Äôexemple de classe suivant :

        >>>   class Number:
                def __init__(self, value):
                  self.value = value

        >>>   Number(42).__dict__
        {value : 42}
            
L‚Äôattribut sp√©cial .__dict__ est un dictionnaire qui associe les noms des attributs √† leurs valeurs correspondantes dans les classes et objets Python. Cette impl√©mentation permet une recherche rapide et efficace des attributs et des m√©thodes dans le cadre de la programmation orient√©e objet.

Vous pouvez utiliser les dictionnaires pour r√©soudre de nombreuses t√¢ches de programmation dans votre code Python. Ils sont particuli√®rement utiles pour traiter des fichiers CSV et JSON, interagir avec des bases de donn√©es, charger des fichiers de configuration, et bien plus encore.

Les dictionnaires en python poss√®dent les carract√©ristiques suivantes :
- Mutables : les valeurs d‚Äôun dictionnaire peuvent √™tre modifi√©es directement.
- Dynamiques : ils peuvent grandir ou r√©tr√©cir selon les besoins.
- Efficaces : ils sont impl√©ment√©s sous forme de tables de hachage, ce qui permet une recherche rapide des cl√©s.
- Ordonn√©s : Depuis 3.7, les dictionnaires conservent l'ordre d'insertion des √©l√©m√©nts.

Les cl√©s d‚Äôun dictionnaire sont soumises √† quelques restrictions. Elles doivent √™tre :
- Hashables : cela signifie que vous ne pouvez pas utiliser des objets non hachables, comme les listes, les dict, les set en tant que cl√©, car ce sont des structures mutables
- Unique : un dictionnaire ne peut pas contenir de cl√©s en double.

Les types hachables : 
- int, float, str, bytes
- tuple (si tous ces √©lements sont hachables)
- frozenSet(set immuable)
- bool (sous-classe de int)
- instances d'objets personnalis√©s si leur classe definit/autorise __hash__ et reste immuable

En revanche, les valeurs d‚Äôun dictionnaire n‚Äôont pas de restrictions.

Elles peuvent √™tre de n‚Äôimporte quel type Python, y compris d‚Äôautres dictionnaires, ce qui permet de cr√©er des dictionnaires imbriqu√©s (nested dictionaries).

Il est important de noter que les dictionnaires sont des collections de paires cl√©-valeur. Vous ne pouvez pas ins√©rer une cl√© sans valeur correspondante, ni une valeur sans cl√©. Comme elles vont toujours de pair, vous devez ins√©rer les deux simultan√©ment.

üí° Remarque : Dans certains cas, vous pouvez vouloir ajouter des cl√©s √† un dictionnaire sans encore conna√Ætre la valeur associ√©e.
Dans ces situations, vous pouvez utiliser la m√©thode .setdefault() pour cr√©er des cl√©s avec une valeur par d√©faut ou une valeur temporaire (placeholder).

En pratique, vous utiliserez un dictionnaire chaque fois que vous aurez besoin d‚Äôune structure de donn√©es mutable et efficace qui associe des cl√©s √† des valeurs.

--- 

### Cr√©er des dictionnaires en Python
Vous pouvez cr√©er des dictionnaires Python de plusieurs mani√®res, selon nos besoins.

La methode la plus courante consiste a utiliser des litt√©raux de dictionnaire, c'est-√†-dire une s√©rie de paire cl√©-valuer s√©par√©es par des virfules, entour√©es d'accolades {}.

La seconde methode consiste √† utiliser le constructeur dict(), qui permet de cr√©er des dictionnaires √† partir :
- d'it√©rables contenant des paires cl√©-valeur.
- d'autres dictionnaires (ou mappings).
- ou encore d'une s√©rie d'arguments nomm√©s (keyword arguments).

Vous pouvez aussi cr√©er un dictionnaire vide en appelant dict() sans argument.

Nous allons voir en d√©tail la cr√©ation de dictionnaire a l'aide de litt√©reaux et du constructeur dict()

#### Lit√©raux de dictionnaire
Vous pouvez d√©finir un dictionnaire en entourant une serie de paire cl√©-valeur par des acolades {}, chaque paire √©tant s√©par√©e par une virgule et chaque cl√© √©tant s√©par√©e de sa valeur par un deux-points (:).

Voici la syntaxe d'un litt√©ral de dict : 

    {
      <cl√©_1>: <valeur_1>,
      <cl√©_2>: <valeur_2>,
      ...,
      <cl√©_N>: <valeur_N>,
    }

Les cl√©s et les valeurs sont facultatives, ce qui signifie que vous pouvez simplement √©crire {} pour cr√©er un dictionnaire vide.

      my_dict = {}
      >>> On cr√©e un dictionnaire vide, via le lit√©raux de dictionnaire

Chaque √©l√©ment est une paire compos√©e d‚Äôune cl√©, d‚Äôun deux-points et de la valeur associ√©e. Les paires sont s√©par√©es par des virgules.

Les cl√©s doivent √™tre des objets hachables, comme des nombres, des cha√Ænes de caract√®res ou des tuples.

√ätre hachable signifie que l‚Äôobjet peut √™tre pass√© √† une fonction de hachage, qui transforme des donn√©es de taille arbitraire en une valeur de taille fixe, appel√©e valeur de hachage (hash). Cette valeur est utilis√©e pour les recherches et comparaisons dans une table de hachage.

Simplement, en Python, les types immuables sont hachables, tandis que les types mutables ne le sont pas.

üí° Remarque : Les ensembles (sets) utilisent √©galement les accolades {}, mais pour contenir des √©l√©ments uniques, et non des paires cl√©-valeur. Pour cr√©er un ensemble vide, il faut utiliser set() au lieu de {}, car cette derni√®re notation est r√©serv√©e aux dictionnaires vides.

Exemple : dictionnaire de clubs de baseball
    
    >>> MLB_teams = {
    ...     "Colorado": "Rockies",
    ...     "Chicago": "White Sox",
    ...     "Boston": "Red Sox",
    ...     "Minnesota": "Twins",
    ...     "Milwaukee": "Brewers",
    ...     "Seattle": "Mariners",
    ... }

Ici, chaque cl√© correspond √† une ville ou un √âtat, et chaque valeur √† une √©quipe de la MLB (Major League Baseball).

#### Cl√©s hachables valides
Vous pouvez utiliser diff√©rents types d‚Äôobjets hachables comme cl√©s :

    >>> {
          42: "aaa",
          2.78: "bbb",
          True: "ccc",
    }

Vous pouvez m√™me utiliser des types de donn√©es ou des fonctions comme cl√©s :

    >>> types = {int: 1, float: 2, bool: 3}
    
    >>> print(types)
    {<class 'int'>: 1, <class 'float'>: 2, <class 'bool'>: 3}

    >>> types[float]
    2

    >>> types[bool]
    3

#### Objets non hachables
Vous ne pouvez pas utiliser d‚Äôobjets non hachables comme cl√©s. Par exemple, les listes sont mutables et donc non hachables :

          >>> {[1, 2]: "Une liste comme cl√© ? Hmm..."}
          
          Traceback (most recent call last):
          ...
          
          TypeError: unhashable type: 'list'

Les listes ne sont pas hachables car si leur contenu changeait, leur valeur de hachage changerait aussi, ce qui violerait la r√®gle selon laquelle le hash d‚Äôun objet doit rester constant. 

En pratique, vous ne pouvez donc pas utiliser de type mutable (liste, ensemble, dictionnaire) comme cl√©.


#### Utiliser des tuples comme cl√©s

Si vous avez besoin d‚Äôutiliser des s√©quences comme cl√©s, vous pouvez utiliser des tuples, car ils sont immuables :

          >>> a_dict = {(1, 1): "a", (1, 2): "b", (2, 1): "c", (2, 2): "d"}
          >>> a_dict[(1, 1)]
          'a'
          >>> a_dict[(2, 1)]
          'c'

Cependant, attention : un tuple contenant un objet mutable (comme une liste) n‚Äôest plus hachable :
        
        >>> {(1, [1, 1]): "a"}
        Traceback (most recent call last):
        ...
        TypeError: unhashable type: 'list'

Car, un tuple est immuable mais les √©l√©ments que contient un tuple eux peuvent √™tre mutable :
-  Un tuple de int,str,bool... est immuable.
- Un tupplue de list, dict... est immuable mais contient des objet mutables donc pas hashable.

#### Pas de doublons de cl√©s
Les cl√©s du dictionnaire doivent √™tre uniques. Si vous assignez une valeur √† une cl√© d√©j√† existante, la valeur pr√©c√©dente est remplac√©e :

        >>> MLB_teams["Chicago"] = "Cubs"
        >>> MLB_teams
        {
          'Colorado': 'Rockies',
          'Chicago': 'Cubs',
          'Boston': 'Red Sox',
          'Minnesota': 'Twins',
          'Milwaukee': 'Brewers',
          'Seattle': 'Mariners',
        }

Ici, "Chicago": "White Sox" a √©t√© remplac√© par "Chicago": "Cubs".


#### Valeurs de dictionnaire
Contrairement aux cl√©s, les valeurs n‚Äôont aucune restriction.
Elles peuvent √™tre de n‚Äôimporte quel type, y compris des objets mutables (listes, ensembles, dictionnaires) ou des objets personnalis√©s :

        >>> class Point:
        ...     def __init__(self, x, y):
        ...         self.x = x
        ...         self.y = y
        ...

        >>> {
        ...     "colors": ["red", "green", "blue"],
        ...     "plugins": {"py_code", "dev_sugar", "fasting_py"},
        ...     "timeout": 3,
        ...     "position": Point(42, 21),
        ... }

Dans cet exemple, le dictionnaire contient une liste, un ensemble, un entier, et un objet personnalis√©.
Tout cela fonctionne car les valeurs n‚Äôont aucune contrainte.

De plus, une m√™me valeur peut appara√Ætre plusieurs fois :

          >>> {0: "a", 1: "a", 2: "a", 3: "a"}
          {0: 'a', 1: 'a', 2: 'a', 3: 'a'}
          
Ici, la valeur "a" est utilis√©e plusieurs fois, ce qui est parfaitement autoris√©.

---

## Le constructeur dict()
Vous pouvez √©galement construire des dictionnaires √† l‚Äôaide du constructeur dict().
Les arguments de dict() peuvent √™tre :
- Une s√©rie d‚Äôarguments nomm√©s (keyword arguments) ;
- un autre dictionnaire (ou mappage) ;
- ou encore un it√©rable de paires cl√©‚Äìvaleur.

Voici les diff√©rentes signatures possibles du constructeur :

    dict()
    dict(**kwargs)
    dict(mapping, **kwargs)
    dict(iterable, **kwargs)

Si on appel le constructeur dict(), sans argument, on obtient un dictionnaire vide :

      >>> dict()
          {}
Dans la plupart des cas, on utilise simplement une paire d‚Äôaccolades vides {} pour cr√©er un dictionnaire vide.

Cependant, dans certaines situations, utiliser le constructeur dict() peut rendre le code plus explicite.

#### Qu'est ce que **kwargs ? 

**kwargs sert √† r√©cup√©rer des arguments nomm√©s (comme cl√©=valeur) dans une fonction.

kwargs signifie "keyword arguments", c‚Äôest-√†-dire arguments nomm√©s.
- ** indique que la fonction peut recevoir un nombre variable d'arguments nomm√©s(sous forme de dictionnaire)
- le mot kwargs est une convention : On pourrait l'appeler (**params, par exemple) mais la norme est **kwargs

      def test(**kwargs):
        print(type(kwargs))
        print(kwargs)

      test(a=1, b=2)

      >>> <class 'dict'>
      >>> {'a': 1, 'b': 2}

üîπ Ici, kwargs n‚Äôest pas un dictionnaire que tu passes toi-m√™me, mais Python le transforme en dictionnaire pour toi √† l‚Äôint√©rieur de la fonction. C‚Äôest pour √ßa qu‚Äôon dit que kwargs se comporte comme un dictionnaire.

#### üß± 4. Lien avec le constructeur dict(**kwargs)

Quand tu √©cris :

      d = dict(nom="Alice", age=30)
üëâ Python passe en interne les arguments nomm√©s sous forme de **kwargs √† la fonction dict(), et dict() les transforme en un vrai dictionnaire :

      >>> {'nom': 'Alice', 'age': 30}

A la diff√©rence avec *args, pour les arguments positionnels.

#### üß© 1. Signification de *args
- *args veut dire "arguments" (sans mots-cl√©s).
- * indique que la fonction peut recevoir un nombre variable d‚Äôarguments positionnels,
- et les regroupe dans un tuple (un ensemble ordonn√© et immuable).

      def addition(*args):
        print(args)

      addition(1, 2, 3)

      >>> (1, 2, 3)

#### Exemple combine **kwargs et *args

    def demo(a, b, *args, **kwargs):
      print("a =", a)
      print("b =", b)
      print("args =", args)
      print("kwargs =", kwargs)

    demo(10, 20, 30, 40, 50, nom="Alice", age=30)

Resultat : 

      a = 10
      b = 20
      args = (30, 40, 50)
      kwargs = {'nom': 'Alice', 'age': 30}

- a et b ‚Üí les deux premiers arguments normaux
- *args ‚Üí tout ce qui reste sans nom
- **kwargs ‚Üí tout ce qui reste avec un nom

### 1. Cr√©er des dictionnaires avec les keyword arguments

Si les cl√©s de votre dictionnaire sont des cha√Ænes de caract√®res qui repr√©sentent des identifiants Python valides, vous pouvez les sp√©cifier comme arguments nomm√©s.
Voici un exemple avec un dictionnaire MLB_teams :

      >>> MLB_teams = dict(
      ...     Colorado="Rockies",
      ...     Chicago="White Sox",
      ...     Boston="Red Sox",
      ...     Minnesota="Twins",
      ...     Milwaukee="Brewers",
      ...     Seattle="Mariners",
      ... )

      # Output =>
      {
        'Colorado': 'Rockies',
        'Chicago': 'White Sox',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners'
      }

Voyons pourquoi les cl√©s ne sont pas entour√©es de guillemets, m√™me si elles deviennent bien des cha√Ænes de caract√®res dans le dictionnaire final.

Quand tu √©cris : 

      MLB_teams = dict(
      Colorado="Rockies",
      Chicago="White Sox",
      Boston="Red Sox"
      )

Python ,e voit pas √ßa comme des paire cl√©:valeur, mais comme des arguments nomm√©s pass a la fonction dict().

Autrement dit, c'est exactement comme si on appelais une fonction classique :

      def ma_fonction(Colarado="Rockies", Chicago="White Sox")

Ici les noms Colorado, Chicago... sont des identifiants pythons, pas des chaines.
Mais lorsque dict() recoit ses arguments, Pythons les convertit automatiquement en cl√© de type str dans le dictionnaire.

#### Ce qu‚Äôil se passe sous le capot

Python fait ceci :
- Il lit tes arguments nomm√©s (Colorado="Rockies", etc.)
- Il cr√©e un dictionnaire interne :

      {"Colorado": "Rockies", "Chicago": "White Sox", "Boston": "Red Sox"}

- Il passe ce dict √† dict(**kwargs)
- Le constructeur dict() cr√©e ton vrai dictionnaire √† partir de √ßa.

#### ‚ö†Ô∏è Limitation importante

Cette syntaxe ne marche que si les cl√©s sont des identifiants Python valides :
- Pas d‚Äôespaces ("New York" ‚ùå)
- Pas de tirets ("Los-Angeles" ‚ùå)
- Pas de chiffres au d√©but ("2Pac" ‚ùå)
- Pas de caract√®res sp√©ciaux ("Caf√©" ‚ùå si accent non g√©r√©)

--- 

### 2. Cr√©er un dictionnaire √† partir d‚Äôun it√©rable de paires cl√©‚Äìvaleur

Vous pouvez aussi cr√©er un dictionnaire √† partir d‚Äôun it√©rable de paires (cl√©, valeur). Voici comment construire le m√™me dictionnaire MLB_teams de cette mani√®re

    >>> MLB_teams = dict(
    ...     [
    ...         ("Colorado", "Rockies"),
    ...         ("Chicago", "White Sox"),
    ...         ("Boston", "Red Sox"),
    ...         ("Minnesota", "Twins"),
    ...         ("Milwaukee", "Brewers"),
    ...         ("Seattle", "Mariners"),
    ...     ]
    ... )

  R√©sultat :

      {
        'Colorado': 'Rockies',
        'Chicago': 'White Sox',
        'Boston': 'Red Sox',
        'Minnesota': 'Twins',
        'Milwaukee': 'Brewers',
        'Seattle': 'Mariners'  
      }

Dans cet exemple, vous construisez le dictionnaire √† partir d‚Äôune liste de tuples contenant deux √©l√©ments :
- le premier est la cl√©, le second est la valeur associ√©e.


### 3. Combiner zip() et dict()

Une m√©thode √©l√©gante pour cr√©er des dictionnaires √† partir de deux s√©quences consiste √† utiliser la fonction int√©gr√©e zip(), puis √† appeler dict() :


          >>> places = [
          ...     "Colorado",
          ...     "Chicago",
          ...     "Boston",
          ...     "Minnesota",
          ...     "Milwaukee",
          ...     "Seattle",
          ... ]

          >>> teams = [
          ...     "Rockies",
          ...     "White Sox",
          ...     "Red Sox",
          ...     "Twins",
          ...     "Brewers",
          ...     "Mariners",
          ... ]

          >>> dict(zip(places, teams))
          {
          'Colorado': 'Rockies',
          'Chicago': 'White Sox',
          'Boston': 'Red Sox',
          'Minnesota': 'Twins',
          'Milwaukee': 'Brewers',
          'Seattle': 'Mariners'
        }

La fonction zip() prend un ou plusieurs it√©rables en argument et renvoie des tuples combinant les √©l√©ments de chaque it√©rable.

üß† Remarque importante :
Vos donn√©es d‚Äôorigine doivent √™tre ordonn√©es dans le bon ordre, car zip() associe les √©l√©ments position par position. Sinon, vous risquez d‚Äôobtenir un dictionnaire qui associe les mauvaises cl√©s aux mauvaises valeurs.


### La methode fromkeys() 
Le type dict poss√®de une m√©thode de classe appel√©e .fromkeys(), qui permet de cr√©er un nouveau dictionnaire √† partir :
- d‚Äôun it√©rable de cl√©s,
- et d‚Äôune valeur par d√©faut.

Sa signature est la suivante :

          dict.fromkeys(iterable, value=None)

          iterable : contient les cl√©s que vous voulez inclure dans le dictionnaire.
          M√™me si cet it√©rable contient des doublons, le dictionnaire final aura des cl√©s uniques (comme toujours).

          value : permet de d√©finir une valeur par d√©faut pour toutes les cl√©s.
          Si vous ne pr√©cisez rien, la valeur par d√©faut sera None.

          >>> inventory = dict.fromkeys(["apple", "orange", "banana", "mango"], 0)
          
          >>> inventory
          {'apple': 0, 'orange': 0, 'banana': 0, 'mango': 0}

---

## üîπ Acc√©der aux valeurs d‚Äôun dictionnaire
Une fois que vous avez cr√©√© un dictionnaire, vous pouvez acc√©der √† son contenu en utilisant ses cl√©s.
Pour r√©cup√©rer une valeur √† partir d‚Äôun dictionnaire, il suffit d‚Äôindiquer la cl√© correspondante entre crochets ([]) apr√®s le nom du dictionnaire :

      >>> MLB_teams["Minnesota"]
      'Twins'

      >>> MLB_teams["Colorado"]
      'Rockies'

Autrement dit, vous pouvez indexer (subscript) un dictionnaire avec une cl√© sp√©cifique pour obtenir la valeur associ√©e.

‚úÖ La recherche d‚Äôune cl√© dans un dictionnaire est une op√©ration tr√®s efficace, car les dictionnaires en Python sont impl√©ment√©s sous la forme de tables de hachage (hash tables).



#### ‚ö†Ô∏è Cl√© inexistante

Si vous essayez d‚Äôacc√©der √† une cl√© qui n‚Äôexiste pas dans le dictionnaire,

Python l√®ve une exception :

      >>> MLB_teams["Indianapolis"]
      Traceback (most recent call last):
      ...
      
      KeyError: 'Indianapolis'
      
‚û°Ô∏è Autrement dit, lorsqu‚Äôon tente d‚Äôacc√©der √† une cl√© absente, Python d√©clenche une erreur KeyError.

#### üîπ Exemple : dictionnaire imbriqu√©

Supposons maintenant que vous ayez le dictionnaire suivant contenant les donn√©es d‚Äôune personne :

      >>> person = {
      ...     "first_name": "John",
      ...     "last_name": "Doe",
      ...     "age": 35,
      ...     "spouse": "Jane",
      ...     "children": ["Ralph", "Betty", "Bob"],
      ...     "pets": {"dog": "Frieda", "cat": "Sox"},
      ... }

Ce dictionnaire contient :
- une liste comme valeur associ√©e √† la cl√© "children" ;
- un autre dictionnaire comme valeur associ√©e √† la cl√© "pets".

üîç Acc√©der √† une liste imbriqu√©e

Pour acc√©der √† un √©l√©ment d‚Äôune liste contenue dans le dictionnaire, vous utilisez d‚Äôabord la cl√© correspondante, puis l‚Äôindex souhait√© :
      
      >>> person["children"][0]
      'Ralph'

      >>> person["children"][2]
      'Bob'

üê∂ Acc√©der √† un dictionnaire imbriqu√©

Pour acc√©der √† une valeur √† l‚Äôint√©rieur d‚Äôun dictionnaire imbriqu√©, vous utilisez la cl√© du dictionnaire ext√©rieur, puis la cl√© int√©rieure :

    >>> person["pets"]["dog"]
    'Frieda'
    
    >>> person["pets"]["cat"]
    'Sox'

üß† En r√©sum√©

Utiliser une cl√© pour acc√©der √† une valeur dans un dictionnaire :
- dictionnaire["cl√©"]
- Utiliser cl√© + index pour acc√©der √† une valeur dans une liste imbriqu√©e.
- Utiliser cl√© ext√©rieure + cl√© int√©rieure pour acc√©der √† une valeur dans un dictionnaire imbriqu√©.
- Le niveau d‚Äôimbrication d√©termine combien de cl√©s ou d‚Äôindices il faut encha√Æner.
